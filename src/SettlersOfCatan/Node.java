// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

/**
 * Node.java - A class to track all the nodes and settlements in the game
 */
package SettlersOfCatan;
import java.util.List;
import java.util.ArrayList;


/**
 * A vertex between tiles on the board where a settlement/city can be built.
 */
public class Node {
	private final int id;
	private Building building;
	private Player occupyingPlayer;
	private List<Node> adjacentNodes;
	private List<Tile> adjacentTiles;


	/**
	 * Constructor
	 * @param id - The id of the node
	 */
	public Node(int id){
		this.id = id;
		this.building = null;
		this.occupyingPlayer = null;
		this.adjacentNodes = new ArrayList<>();
		this.adjacentTiles = new ArrayList<>();


	}


	// GETTERS & SETTERS

	/**
	 * Gets the node id
	 * @return id - The id of the node
	 */
	public int getId(){
		return id;
	}

	/**
	 * Gets the current building
	 * @return building
	 */
	public Building getBuilding(){
		return building;
	}

	/**
	 * Sets the current building
	 * @param building
	 */
	public void setBuilding(Building building){
		this.building = building;
	}

	/**
	 * Gets the current player occupying the node
	 * @return occupyingPlayer
	 */
	public Player getOccupyingPlayer(){
		return occupyingPlayer;
	}

	/**
	 * Sets the player occupying the node
	 * @param player - The player to occupy the node
	 */
	public void setOccupyingPlayer(Player player){
		this.occupyingPlayer = player;
	}

	/**
	 * Gets the adjacent nodes
	 * @return adjacentNodes - The nodes next to the current node
	 */
	public List<Node> getAdjacentNodes() {
		return adjacentNodes;
	}

	/**
	 * Gets the adjacent tiles
	 * @return adjacentTiles - The tiles next to the current tile
	 */
	public List<Tile> getAdjacentTiles() {
		return adjacentTiles;
	}



	// GAME LOGIC METHODS

	/**
	 * Adds an adjacent node if there is no node next to the current node
	 */
	public void addAdjacentNode(){
		if(!adjacentNodes.contains(node)){
			adjacentNodes.add(node);
		}
	}

	/**
	 * Adds an ajacent tile if there is no tile next to the current tile
	 */
	public void addAdjacentTile(){
		if(!adjacentTiles.contains(tile)){
			adjacentTiles.add(tile);
		}
	}


	/**
	 * Checks if a building can be placed at the node
	 * @return true if building can be placed
	 * @ return false if building cannot be placed
	 */
	public boolean canPlaceBuilding() {

		// check for buildings
		if (building != null){
			return false;
		}

		// no adjacent nodes can have buildings - distance rule
		for (Node adjacent : adjacentNodes) {
			if (adjacent.getBuilding() != null) {
				return false;
			}
		}

		return true;
	}

	/**
	 * Places a settlement at the node for the given player
	 */
	public void placeSettlement(){
		this.building = Building.SETTLEMENT;
		this.occupyingPlayer = player;
	}

	/**
	 * Upgrades a settlement to a city, if the settlement exists
	 * @return
	 */
	public boolean upgradeToCity(){
		if(building == Building.SETTLEMENT){
			building = Building.CITY;
			return true;
		}
		return false;
	}

	/**
	 * Checks if the Node is occupied by any player
	 * @return true if the node is occupied by a player, false otherwise
	 */
	public boolean isOccupied(){
		return building != null;
	}


}
