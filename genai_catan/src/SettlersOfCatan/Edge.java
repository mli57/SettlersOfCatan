// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package SettlersOfCatan;

import java.util.ArrayList;
import java.util.List;

/**
 * Represents a path (edge) on the Catan board connecting two nodes.
 * Roads are placed on edges. Only one road may occupy each edge.
 *
 * UML: Edge with attributes id, nodeA, nodeB, occupyingPlayer, road.
 *       Operations: canPlaceRoad(), getAdjacentEdges().
 */
public class Edge {

    private final int id;
    private final Node nodeA;
    private final Node nodeB;
    private Player occupyingPlayer;
    private Road road;

    public Edge(int id, Node nodeA, Node nodeB) {
        this.id = id;
        this.nodeA = nodeA;
        this.nodeB = nodeB;
        this.occupyingPlayer = null;
        this.road = null;

        // Register this edge with both endpoint nodes
        nodeA.addEdge(this);
        nodeB.addEdge(this);

        // Make the endpoint nodes aware they are adjacent
        nodeA.addAdjacentNode(nodeB);
        nodeB.addAdjacentNode(nodeA);
    }

    /**
     * Checks whether the given player may place a road on this edge.
     * Requirements:
     *  1. No road already here.
     *  2. Player has an existing road, settlement, or city connected
     *     to at least one endpoint (opponent settlements block
     *     road continuation through that node).
     */
    public boolean canPlaceRoad(Player player, boolean isSetupPhase) {
        if (road != null) {
            return false;
        }
        if (isSetupPhase) {
            // During setup the road must touch the settlement just placed
            return nodeA.getOccupyingPlayer() == player
                || nodeB.getOccupyingPlayer() == player;
        }

        // Normal play: check building on either endpoint
        if (nodeA.getOccupyingPlayer() == player || nodeB.getOccupyingPlayer() == player) {
            return true;
        }

        // Check road connectivity through unblocked nodes
        if (hasConnectedRoad(nodeA, player) || hasConnectedRoad(nodeB, player)) {
            return true;
        }
        return false;
    }

    /**
     * Helper: does the player have a road at this node, AND is the node not
     * blocked by an opponent's settlement/city?
     */
    private boolean hasConnectedRoad(Node node, Player player) {
        // If an opponent occupies the node, roads cannot connect through it
        if (node.getOccupyingPlayer() != null && !node.getOccupyingPlayer().equals(player)) {
            return false;
        }
        for (Edge e : node.getEdges()) {
            if (e != this && e.road != null && e.road.getOwner().equals(player)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Places a road on this edge.
     */
    public void placeRoad(Road road, Player player) {
        this.road = road;
        this.occupyingPlayer = player;
    }

    /**
     * Returns all edges that share an endpoint with this edge.
     */
    public List<Edge> getAdjacentEdges() {
        List<Edge> adjacent = new ArrayList<>();
        for (Edge e : nodeA.getEdges()) {
            if (e != this) adjacent.add(e);
        }
        for (Edge e : nodeB.getEdges()) {
            if (e != this) adjacent.add(e);
        }
        return adjacent;
    }

    /**
     * Given one endpoint, return the other.
     */
    public Node getOtherNode(Node node) {
        if (node.equals(nodeA)) return nodeB;
        if (node.equals(nodeB)) return nodeA;
        throw new IllegalArgumentException("Node " + node.getId()
            + " is not an endpoint of Edge " + id);
    }

    // ========== Getters ==========

    public int getId()                  { return id; }
    public Node getNodeA()              { return nodeA; }
    public Node getNodeB()              { return nodeB; }
    public Player getOccupyingPlayer()  { return occupyingPlayer; }
    public Road getRoad()               { return road; }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Edge)) return false;
        return id == ((Edge) o).id;
    }

    @Override
    public int hashCode() { return id; }

    @Override
    public String toString() {
        String r = road == null ? "empty" : road.getOwner().getColor().name();
        return String.format("Edge(%d) [%d-%d] %s", id, nodeA.getId(), nodeB.getId(), r);
    }
}
