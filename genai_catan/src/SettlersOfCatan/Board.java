// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package SettlersOfCatan;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Represents the Catan game board.
 * Contains 19 hex tiles in the standard layout, 54 nodes (intersections),
 * and 72 edges (paths). Uses cube coordinates (q, r, s) for hex positioning.
 *
 * UML: Board with attributes tile[19], nodes[54], edges[72].
 *       Operations: initialize(), produceResources(), moveRobber().
 */
public class Board {

    public static final int NUM_TILES = 19;
    public static final int NUM_NODES = 54;
    public static final int NUM_EDGES = 72;

    private final List<Tile> tiles;
    private final List<Node> nodes;
    private final List<Edge> edges;
    private Tile robberTile;

    // Standard terrain distribution:
    //   4 WHEAT (fields), 4 WOOD (forest), 4 SHEEP (pasture),
    //   3 BRICK (hills), 3 ORE (mountains), 1 DESERT
    private static final TerrainType[] TERRAIN_DISTRIBUTION = {
        TerrainType.WHEAT, TerrainType.WHEAT, TerrainType.WHEAT, TerrainType.WHEAT,
        TerrainType.WOOD,  TerrainType.WOOD,  TerrainType.WOOD,  TerrainType.WOOD,
        TerrainType.SHEEP, TerrainType.SHEEP, TerrainType.SHEEP, TerrainType.SHEEP,
        TerrainType.BRICK, TerrainType.BRICK, TerrainType.BRICK,
        TerrainType.ORE,   TerrainType.ORE,   TerrainType.ORE,
        TerrainType.DESERT
    };

    // 18 number tokens placed on non-desert tiles
    private static final int[] NUMBER_TOKENS = {
        5, 2, 6, 3, 8, 10, 9, 12, 11, 4, 8, 10, 9, 4, 5, 6, 3, 11
    };

    // Cube coordinates for all 19 hex positions (rows top to bottom)
    private static final int[][] HEX_COORDS = {
        // Row 0 (3 hexes)
        {0, -2, 2}, {1, -2, 1}, {2, -2, 0},
        // Row 1 (4 hexes)
        {-1, -1, 2}, {0, -1, 1}, {1, -1, 0}, {2, -1, -1},
        // Row 2 (5 hexes – centre)
        {-2, 0, 2}, {-1, 0, 1}, {0, 0, 0}, {1, 0, -1}, {2, 0, -2},
        // Row 3 (4 hexes)
        {-2, 1, 1}, {-1, 1, 0}, {0, 1, -1}, {1, 1, -2},
        // Row 4 (3 hexes)
        {-2, 2, 0}, {-1, 2, -1}, {0, 2, -2}
    };

    public Board() {
        this.tiles = new ArrayList<>(NUM_TILES);
        this.nodes = new ArrayList<>(NUM_NODES);
        this.edges = new ArrayList<>(NUM_EDGES);
    }

    /**
     * Fully initialises the board: shuffles terrain, creates hex topology,
     * assigns number tokens, and places the robber on the desert.
     */
    public void initialize(Random random) {
        createTiles(random);
        createNodesAndEdges();
        assignNumberTokens(random);

        // Place robber on desert
        for (Tile t : tiles) {
            if (t.getResource() == TerrainType.DESERT) {
                robberTile = t;
                t.setRobber(true);
                break;
            }
        }
    }

    // ==================== Board Construction ====================

    private void createTiles(Random random) {
        List<TerrainType> terrains = new ArrayList<>(Arrays.asList(TERRAIN_DISTRIBUTION));
        Collections.shuffle(terrains, random);
        for (int i = 0; i < NUM_TILES; i++) {
            int[] c = HEX_COORDS[i];
            tiles.add(new Tile(c[0], c[1], c[2], terrains.get(i)));
        }
    }

    /**
     * Generates the 54 unique nodes and 72 unique edges from the hex grid.
     * Uses pixel-position rounding to deduplicate shared vertices.
     */
    private void createNodesAndEdges() {
        Map<String, Node> nodeMap = new LinkedHashMap<>();
        Map<String, Edge> edgeMap = new LinkedHashMap<>();
        int nodeId = 0;
        int edgeId = 0;

        // Pointy-top hex vertex offsets (unit size) at angles –30°, 30°, 90°, …
        double[][] vOff = new double[6][2];
        for (int i = 0; i < 6; i++) {
            double rad = Math.toRadians(60.0 * i - 30.0);
            vOff[i][0] = Math.cos(rad);
            vOff[i][1] = Math.sin(rad);
        }

        for (Tile tile : tiles) {
            // Convert cube → pixel (pointy-top)
            double cx = Math.sqrt(3.0) * tile.getQ() + Math.sqrt(3.0) / 2.0 * tile.getR();
            double cy = 1.5 * tile.getR();

            Node[] tileVerts = new Node[6];

            for (int i = 0; i < 6; i++) {
                String key = coordKey(cx + vOff[i][0], cy + vOff[i][1]);
                if (!nodeMap.containsKey(key)) {
                    nodeMap.put(key, new Node(nodeId++));
                }
                tileVerts[i] = nodeMap.get(key);
                tile.addNode(tileVerts[i]);
                tileVerts[i].addAdjacentTile(tile);
            }

            // Create edges between consecutive vertices
            for (int i = 0; i < 6; i++) {
                Node nA = tileVerts[i];
                Node nB = tileVerts[(i + 1) % 6];
                String eKey = edgeKey(nA.getId(), nB.getId());
                if (!edgeMap.containsKey(eKey)) {
                    edgeMap.put(eKey, new Edge(edgeId++, nA, nB));
                }
                tile.addEdge(edgeMap.get(eKey));
            }
        }

        nodes.addAll(nodeMap.values());
        edges.addAll(edgeMap.values());
    }

    /**
     * Assigns number tokens to non-desert tiles, then ensures
     * that red numbers (6 and 8) are never on adjacent hexes.
     */
    private void assignNumberTokens(Random random) {
        List<Integer> nums = new ArrayList<>();
        for (int n : NUMBER_TOKENS) nums.add(n);
        Collections.shuffle(nums, random);

        int idx = 0;
        for (Tile t : tiles) {
            if (t.getResource() != TerrainType.DESERT) {
                t.setNumber(nums.get(idx++));
            }
        }
        resolveRedNumberConflicts();
    }

    /** Swap tokens so that 6 and 8 are never adjacent. */
    private void resolveRedNumberConflicts() {
        for (int attempt = 0; attempt < 100; attempt++) {
            boolean conflict = false;
            for (Tile t : tiles) {
                if (t.getNumber() != 6 && t.getNumber() != 8) continue;
                for (Tile adj : t.getAdjacentTiles(tiles)) {
                    if (adj.getNumber() == 6 || adj.getNumber() == 8) {
                        // Find a non-red tile to swap with
                        for (Tile swap : tiles) {
                            if (swap != t && swap != adj
                                    && swap.getResource() != TerrainType.DESERT
                                    && swap.getNumber() != 6 && swap.getNumber() != 8) {
                                int tmp = adj.getNumber();
                                adj.setNumber(swap.getNumber());
                                swap.setNumber(tmp);
                                conflict = true;
                                break;
                            }
                        }
                        if (conflict) break;
                    }
                }
                if (conflict) break;
            }
            if (!conflict) break;
        }
    }

    // ==================== Board Queries ====================

    public Tile getTile(int q, int r, int s) {
        for (Tile t : tiles)
            if (t.getQ() == q && t.getR() == r && t.getS() == s) return t;
        return null;
    }

    public Node getNode(int id) {
        return (id >= 0 && id < nodes.size()) ? nodes.get(id) : null;
    }

    public Edge getEdge(int id) {
        return (id >= 0 && id < edges.size()) ? edges.get(id) : null;
    }

    public List<Tile> getTilesByNumber(int number) {
        return tiles.stream().filter(t -> t.getNumber() == number).collect(Collectors.toList());
    }

    /** All nodes where the player may legally place a settlement. */
    public List<Node> getAvailableSettlementNodes(Player player, boolean setupPhase) {
        return nodes.stream()
                .filter(n -> n.canPlaceSettlement(player, setupPhase))
                .collect(Collectors.toList());
    }

    /** All edges where the player may legally place a road. */
    public List<Edge> getAvailableRoadEdges(Player player, boolean setupPhase) {
        return edges.stream()
                .filter(e -> e.canPlaceRoad(player, setupPhase))
                .collect(Collectors.toList());
    }

    /** Nodes where the player has a settlement that could be upgraded to a city. */
    public List<Node> getUpgradeableCityNodes(Player player) {
        List<Node> result = new ArrayList<>();
        for (Node n : nodes) {
            if (n.getBuilding() instanceof Settlement
                    && n.getOccupyingPlayer().equals(player)) {
                result.add(n);
            }
        }
        return result;
    }

    // ==================== Resource Production ====================

    /**
     * Produces resources for all players based on the dice roll.
     * Settlements yield 1 card; cities yield 2 cards. Robber blocks production.
     * @return map of each player → list of resources gained this roll
     */
    public Map<Player, List<ResourceType>> produceResources(int diceRoll, List<Player> players) {
        Map<Player, List<ResourceType>> production = new LinkedHashMap<>();
        for (Player p : players) production.put(p, new ArrayList<>());

        for (Tile tile : getTilesByNumber(diceRoll)) {
            if (tile.hasRobber()) continue;
            ResourceType res = tile.produceResource();
            if (res == null) continue;

            for (Node node : tile.getNodes()) {
                if (node.getBuilding() != null) {
                    Player owner = node.getOccupyingPlayer();
                    int qty = node.getBuilding().getResourceMultiplier();
                    for (int i = 0; i < qty; i++) {
                        production.get(owner).add(res);
                        owner.addResource(res);
                    }
                }
            }
        }
        return production;
    }

    // ==================== Robber ====================

    /**
     * Moves the robber to a new tile.
     * @return list of players with buildings adjacent to the new robber hex
     */
    public List<Player> moveRobber(Tile newTile) {
        if (robberTile != null) robberTile.setRobber(false);
        newTile.setRobber(true);
        robberTile = newTile;

        Set<Player> victims = new LinkedHashSet<>();
        for (Node n : newTile.getNodes()) {
            if (n.getOccupyingPlayer() != null) victims.add(n.getOccupyingPlayer());
        }
        return new ArrayList<>(victims);
    }

    /** All tiles the robber may legally move to (any tile except current). */
    public List<Tile> getValidRobberTiles() {
        return tiles.stream().filter(t -> t != robberTile).collect(Collectors.toList());
    }

    public Tile getRobberTile() { return robberTile; }

    // ==================== Utility ====================

    private String coordKey(double x, double y) {
        return Math.round(x * 10000) + "," + Math.round(y * 10000);
    }

    private String edgeKey(int a, int b) {
        return Math.min(a, b) + "-" + Math.max(a, b);
    }

    // ==================== Getters ====================

    public List<Tile> getTiles() { return Collections.unmodifiableList(tiles); }
    public List<Node> getNodes() { return Collections.unmodifiableList(nodes); }
    public List<Edge> getEdges() { return Collections.unmodifiableList(edges); }

    @Override
    public String toString() {
        return String.format("Board: %d tiles, %d nodes, %d edges",
                tiles.size(), nodes.size(), edges.size());
    }
}
