// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package SettlersOfCatan;

import java.util.*;

/**
 * Main game controller for Settlers of Catan.
 * Manages the complete game loop: setup phase, player turns (dice roll,
 * trade, build), development cards, special awards, and win detection.
 * Runs as a fully automated bot-driven simulator that produces a game trace.
 *
 * UML: Game with attributes board, players[4], currentPlayer, roundCount.
 *       Composite: Board ◆— Game, Shared: Player ◇— Game.
 *       Association: Game — DiceRoller.
 */
public class Game {

    public static final int VICTORY_POINTS_TO_WIN = 10;
    public static final int NUM_PLAYERS = 4;
    public static final int MAX_ROUNDS  = 200;

    private final Board board;
    private final List<Player> players;
    private final DiceRoller diceRoller;
    private final Deque<DevelopmentCard> developmentCardDeck;
    private final Random random;
    private final List<String> gameTrace;

    private Player currentPlayer;
    private int currentPlayerIndex;
    private int roundCount;
    private int turnCount;
    private boolean gameOver;
    private Player winner;

    // Special-card tracking
    private Player longestRoadHolder;
    private int    longestRoadLength;
    private Player largestArmyHolder;
    private int    largestArmySize;

    public Game() {
        this(System.currentTimeMillis());
    }

    public Game(long seed) {
        this.random             = new Random(seed);
        this.board              = new Board();
        this.players            = new ArrayList<>(NUM_PLAYERS);
        this.diceRoller         = new DiceRoller(seed);
        this.developmentCardDeck = new ArrayDeque<>();
        this.gameTrace          = new ArrayList<>();
        this.currentPlayerIndex = 0;
        this.roundCount         = 0;
        this.turnCount          = 0;
        this.gameOver           = false;
        this.longestRoadLength  = 0;
        this.largestArmySize    = 0;
    }

    // ================================================================
    //                      GAME INITIALISATION
    // ================================================================

    /**
     * Initialises board, players, development-card deck, and runs the
     * two-round setup phase.
     */
    public void initialize() {
        log("=== SETTLERS OF CATAN SIMULATOR ===");

        board.initialize(random);
        log("Board created: " + board);

        PlayerColor[] colors = PlayerColor.values();
        for (int i = 0; i < NUM_PLAYERS; i++) {
            players.add(new Player(colors[i]));
        }
        log("Players: " + players.stream()
                .map(p -> p.getColor().name())
                .reduce((a, b) -> a + ", " + b).orElse(""));

        initDevelopmentCards();
        log("Development card deck: " + developmentCardDeck.size() + " cards");

        logBoardLayout();
        setupPhase();
    }

    /** Creates and shuffles the 25-card development-card deck. */
    private void initDevelopmentCards() {
        List<DevelopmentCard> cards = new ArrayList<>();
        for (int i = 0; i < 14; i++)
            cards.add(new DevelopmentCard(DevelopmentCardType.KNIGHT, "Knight"));
        for (int i = 0; i < 2; i++)
            cards.add(new DevelopmentCard(DevelopmentCardType.ROAD_BUILDING, "Road Building"));
        for (int i = 0; i < 2; i++)
            cards.add(new DevelopmentCard(DevelopmentCardType.YEAR_OF_PLENTY, "Year of Plenty"));
        for (int i = 0; i < 2; i++)
            cards.add(new DevelopmentCard(DevelopmentCardType.MONOPOLY, "Monopoly"));
        String[] vpNames = {"Library", "Market", "Great Hall", "Chapel", "University"};
        for (String n : vpNames)
            cards.add(new DevelopmentCard(DevelopmentCardType.VICTORY_POINT, n));

        Collections.shuffle(cards, random);
        developmentCardDeck.addAll(cards);
    }

    // ================================================================
    //                        SETUP PHASE
    // ================================================================

    /**
     * Two-round snake-draft setup.
     * Round 1: clockwise  —  each player places 1 settlement + 1 road.
     * Round 2: reverse    —  each player places 1 settlement + 1 road and
     *                        collects starting resources from the 2nd settlement.
     */
    private void setupPhase() {
        log("\n=== SETUP PHASE ===");

        log("--- Round 1 (clockwise) ---");
        for (int i = 0; i < NUM_PLAYERS; i++) {
            placeInitialSettlementAndRoad(players.get(i), false);
        }

        log("--- Round 2 (counter-clockwise) ---");
        for (int i = NUM_PLAYERS - 1; i >= 0; i--) {
            Node node = placeInitialSettlementAndRoad(players.get(i), true);
            if (node != null) {
                for (Tile tile : node.getAdjacentTiles()) {
                    ResourceType res = tile.produceResource();
                    if (res != null) {
                        players.get(i).addResource(res);
                        log("  " + players.get(i).getColor() + " receives starting " + res);
                    }
                }
            }
        }

        log("\n--- Setup Complete ---");
        for (Player p : players) log("  " + p.getColor() + ": " + p.getResourceSummary());
    }

    /**
     * Bot AI for initial placement.
     * Scores each available node by the sum of pip-values of adjacent tiles
     * plus a diversity bonus for distinct resource types.
     * @return the Node where the settlement was placed
     */
    private Node placeInitialSettlementAndRoad(Player player, boolean secondRound) {
        List<Node> available = board.getAvailableSettlementNodes(player, true);
        if (available.isEmpty()) {
            log("  WARNING: " + player.getColor() + " has no available setup nodes");
            return null;
        }

        Node best = available.get(0);
        int bestScore = -1;

        for (Node n : available) {
            int score = 0;
            Set<ResourceType> types = EnumSet.noneOf(ResourceType.class);
            for (Tile t : n.getAdjacentTiles()) {
                if (t.getResource() != TerrainType.DESERT) {
                    score += pips(t.getNumber());
                    ResourceType rt = Tile.terrainToResource(t.getResource());
                    if (rt != null) types.add(rt);
                }
            }
            score += types.size() * 2; // diversity bonus
            if (score > bestScore) { bestScore = score; best = n; }
        }

        // Place settlement
        Settlement s = new Settlement(player);
        best.placeBuilding(s, player);
        player.addSettlement(s);
        log("  " + player.getColor() + " places settlement at Node " + best.getId()
                + " (score=" + bestScore + ")");

        // Place road on a random available adjacent edge
        List<Edge> roadEdges = new ArrayList<>();
        for (Edge e : best.getEdges()) if (e.getRoad() == null) roadEdges.add(e);
        if (!roadEdges.isEmpty()) {
            Edge re = roadEdges.get(random.nextInt(roadEdges.size()));
            Road road = new Road(player, re);
            re.placeRoad(road, player);
            player.addRoad(road);
            log("  " + player.getColor() + " places road on Edge " + re.getId());
        }
        return best;
    }

    // ================================================================
    //                       MAIN GAME LOOP
    // ================================================================

    /** Runs the complete game simulation. */
    public void play() {
        log("\n=== GAME START ===");

        while (!gameOver && roundCount < MAX_ROUNDS) {
            playRound();
        }

        if (winner != null) {
            log("\n=== GAME OVER ===");
            log("Winner: " + winner.getColor() + " with "
                    + winner.getVictoryPoints() + " victory points!");
            log("Game lasted " + roundCount + " rounds (" + turnCount + " turns).");
        } else {
            log("\n=== GAME ENDED (max rounds reached) ===");
        }
        logFinalState();
    }

    /** One complete round = each of the 4 players takes a turn. */
    private void playRound() {
        roundCount++;
        for (int i = 0; i < NUM_PLAYERS && !gameOver; i++) {
            currentPlayerIndex = i;
            currentPlayer = players.get(i);
            playTurn(currentPlayer);
        }
    }

    /**
     * Executes a single player turn per Catan rules:
     *   0. (optional) play a knight before rolling
     *   1. Roll dice → resource production OR robber on 7
     *   2. Trade (bot: maritime 4:1)
     *   3. Build (cities > settlements > roads > dev cards)
     *   4. Play progress cards
     *   5. Check victory
     */
    private void playTurn(Player player) {
        turnCount++;
        log("\n--- Round " + roundCount + " | " + player.getColor() + "'s Turn ---");

        // 0. Optionally play a knight before rolling
        playKnightIfBeneficial(player);

        // 1. Roll dice
        int roll = diceRoller.rollTwoDice();
        log(player.getColor() + " rolls " + roll
                + " (" + diceRoller.getLastDie1() + "+" + diceRoller.getLastDie2() + ")");

        if (roll == 7) {
            handleRobber(player);
        } else {
            Map<Player, List<ResourceType>> prod = board.produceResources(roll, players);
            for (Map.Entry<Player, List<ResourceType>> e : prod.entrySet()) {
                if (!e.getValue().isEmpty())
                    log("  " + e.getKey().getColor() + " receives: " + e.getValue());
            }
        }

        // 2. Trade
        botMaritimeTrade(player);

        // 3. Build
        botBuild(player);

        // 4. Progress cards
        playProgressCards(player);

        // 5. Victory check
        if (player.getVictoryPoints() >= VICTORY_POINTS_TO_WIN) {
            gameOver = true;
            winner = player;
            log("\n  *** " + player.getColor() + " WINS with "
                    + player.getVictoryPoints() + " VP! ***");
            return;
        }

        log("  " + player.getColor() + " state: VP=" + player.getVictoryPoints()
                + " [" + player.getResourceSummary() + "]");
    }

    // ================================================================
    //                     ROBBER (rolling 7 / knight)
    // ================================================================

    private void handleRobber(Player roller) {
        log("  *** ROBBER ACTIVATED ***");

        // 1. Every player with >7 cards discards half
        for (Player p : players) {
            if (p.getTotalResourceCount() > 7) {
                List<ResourceType> disc = p.discardHalf();
                log("  " + p.getColor() + " discards " + disc.size() + " cards: " + disc);
            }
        }

        // 2 & 3. Move robber + steal
        moveRobberAndSteal(roller);
    }

    /** Shared logic for moving the robber (used by rolling-7 and knight). */
    private void moveRobberAndSteal(Player mover) {
        List<Tile> valid = board.getValidRobberTiles();
        Tile target = pickRobberTarget(mover, valid);
        List<Player> victims = board.moveRobber(target);
        log("  Robber moved to " + target);

        victims.remove(mover);
        if (!victims.isEmpty()) {
            Player victim = victims.get(random.nextInt(victims.size()));
            ResourceType stolen = victim.getRandomResource(random);
            if (stolen != null) {
                victim.removeResource(stolen);
                mover.addResource(stolen);
                log("  " + mover.getColor() + " steals " + stolen + " from " + victim.getColor());
            }
        }
    }

    /** Bot strategy: move robber to the highest-value hex adjacent to the leading opponent. */
    private Tile pickRobberTarget(Player mover, List<Tile> valid) {
        Tile best = valid.get(0);
        int bestScore = -1;
        for (Tile t : valid) {
            if (t.getResource() == TerrainType.DESERT) continue;
            int score = 0;
            boolean hasOpponent = false;
            for (Node n : t.getNodes()) {
                if (n.getOccupyingPlayer() != null && !n.getOccupyingPlayer().equals(mover)) {
                    hasOpponent = true;
                    score += pips(t.getNumber());
                    score += n.getOccupyingPlayer().getVictoryPoints();
                }
            }
            if (hasOpponent && score > bestScore) { bestScore = score; best = t; }
        }
        return best;
    }

    // ================================================================
    //                     BOT AI – TRADING
    // ================================================================

    /** Simple maritime trade: 4-of-a-kind → 1 needed resource, up to 3 times. */
    private void botMaritimeTrade(Player player) {
        for (int attempt = 0; attempt < 3; attempt++) {
            ResourceType excess = null;
            int maxCount = 3;
            for (ResourceType r : ResourceType.values()) {
                if (player.getResourceCount(r) > maxCount) {
                    maxCount = player.getResourceCount(r);
                    excess = r;
                }
            }
            if (excess != null && maxCount >= 4) {
                ResourceType need = mostNeeded(player);
                if (need != null && need != excess) {
                    player.removeResource(excess, 4);
                    player.addResource(need);
                    log("  " + player.getColor() + " trades 4 " + excess
                            + " → 1 " + need + " (maritime)");
                }
            } else {
                break;
            }
        }
    }

    /** Determines what resource the bot needs most (city > settlement > road). */
    private ResourceType mostNeeded(Player player) {
        if (!player.getSettlements().isEmpty()) {
            if (player.getResourceCount(ResourceType.ORE)   < 3) return ResourceType.ORE;
            if (player.getResourceCount(ResourceType.WHEAT)  < 2) return ResourceType.WHEAT;
        }
        if (player.getResourceCount(ResourceType.BRICK) < 1) return ResourceType.BRICK;
        if (player.getResourceCount(ResourceType.WOOD)  < 1) return ResourceType.WOOD;
        if (player.getResourceCount(ResourceType.SHEEP) < 1) return ResourceType.SHEEP;
        if (player.getResourceCount(ResourceType.WHEAT) < 1) return ResourceType.WHEAT;
        return ResourceType.values()[random.nextInt(ResourceType.values().length)];
    }

    // ================================================================
    //                     BOT AI – BUILDING
    // ================================================================

    private void botBuild(Player player) {
        tryBuildCity(player);
        tryBuildSettlement(player);
        tryBuildRoad(player);
        tryBuyDevCard(player);
    }

    private void tryBuildCity(Player player) {
        if (!player.canBuildCity()) return;
        List<Node> nodes = board.getUpgradeableCityNodes(player);
        if (nodes.isEmpty()) return;

        // Upgrade the most productive settlement
        Node best = nodes.get(0);
        int bestPips = 0;
        for (Node n : nodes) {
            int p = 0;
            for (Tile t : n.getAdjacentTiles()) p += pips(t.getNumber());
            if (p > bestPips) { bestPips = p; best = n; }
        }

        player.payCost(Player.CITY_COST);
        Settlement old = (Settlement) best.getBuilding();
        player.removeSettlement(old);
        City city = new City(player);
        best.upgradeToCity(city);
        player.addCity(city);
        log("  " + player.getColor() + " upgrades to CITY at Node " + best.getId());
    }

    private void tryBuildSettlement(Player player) {
        if (!player.canBuildSettlement()) return;
        List<Node> avail = board.getAvailableSettlementNodes(player, false);
        if (avail.isEmpty()) return;

        Node best = avail.get(0);
        int bestScore = -1;
        for (Node n : avail) {
            int sc = 0;
            for (Tile t : n.getAdjacentTiles()) sc += pips(t.getNumber());
            if (sc > bestScore) { bestScore = sc; best = n; }
        }

        player.payCost(Player.SETTLEMENT_COST);
        Settlement s = new Settlement(player);
        best.placeBuilding(s, player);
        player.addSettlement(s);
        log("  " + player.getColor() + " builds SETTLEMENT at Node " + best.getId());
    }

    private void tryBuildRoad(Player player) {
        if (!player.canBuildRoad()) return;
        List<Edge> avail = board.getAvailableRoadEdges(player, false);
        if (avail.isEmpty()) return;

        // Prefer edges leading toward good empty settlement spots
        Edge best = null;
        int bestScore = -1;
        for (Edge e : avail) {
            int sc = 0;
            for (Node ep : List.of(e.getNodeA(), e.getNodeB())) {
                if (ep.canPlaceBuilding()) {
                    for (Tile t : ep.getAdjacentTiles()) sc += pips(t.getNumber());
                }
            }
            if (sc > bestScore) { bestScore = sc; best = e; }
        }
        if (best == null) best = avail.get(random.nextInt(avail.size()));

        player.payCost(Player.ROAD_COST);
        Road road = new Road(player, best);
        best.placeRoad(road, player);
        player.addRoad(road);
        log("  " + player.getColor() + " builds ROAD on Edge " + best.getId());

        updateLongestRoad();
    }

    private void tryBuyDevCard(Player player) {
        if (!player.canBuyDevelopmentCard() || developmentCardDeck.isEmpty()) return;
        player.payCost(Player.DEV_CARD_COST);
        DevelopmentCard card = developmentCardDeck.poll();
        card.setTurnBought(turnCount);
        player.addDevelopmentCard(card);
        log("  " + player.getColor() + " buys dev card: " + card.getName());
    }

    // ================================================================
    //                  DEVELOPMENT CARD PLAY
    // ================================================================

    private void playKnightIfBeneficial(Player player) {
        for (DevelopmentCard c : player.getDevelopmentCards()) {
            if (c.getType() == DevelopmentCardType.KNIGHT && c.canPlay(turnCount)) {
                c.setPlayed(true);
                player.incrementKnightsPlayed();
                log("  " + player.getColor() + " plays KNIGHT (#" + player.getKnightsPlayed() + ")");
                moveRobberAndSteal(player);
                updateLargestArmy();
                return; // only 1 dev card per turn
            }
        }
    }

    private void playProgressCards(Player player) {
        for (DevelopmentCard c : player.getDevelopmentCards()) {
            if (c.isPlayed() || !c.canPlay(turnCount)) continue;

            switch (c.getType()) {
                case ROAD_BUILDING:
                    c.setPlayed(true);
                    log("  " + player.getColor() + " plays ROAD BUILDING");
                    for (int i = 0; i < 2; i++) {
                        List<Edge> avail = board.getAvailableRoadEdges(player, false);
                        if (!avail.isEmpty() && player.getRoads().size() < Player.MAX_ROADS) {
                            Edge e = avail.get(random.nextInt(avail.size()));
                            Road r = new Road(player, e);
                            e.placeRoad(r, player);
                            player.addRoad(r);
                            log("    Free road on Edge " + e.getId());
                        }
                    }
                    updateLongestRoad();
                    return;

                case YEAR_OF_PLENTY:
                    c.setPlayed(true);
                    ResourceType r1 = mostNeeded(player);
                    ResourceType r2 = mostNeeded(player);
                    player.addResource(r1);
                    player.addResource(r2);
                    log("  " + player.getColor() + " plays YEAR OF PLENTY: " + r1 + ", " + r2);
                    return;

                case MONOPOLY:
                    c.setPlayed(true);
                    // Pick the resource opponents hold the most of
                    ResourceType target = ResourceType.WHEAT;
                    int maxTotal = 0;
                    for (ResourceType rt : ResourceType.values()) {
                        int tot = 0;
                        for (Player o : players)
                            if (!o.equals(player)) tot += o.getResourceCount(rt);
                        if (tot > maxTotal) { maxTotal = tot; target = rt; }
                    }
                    int stolen = 0;
                    for (Player o : players) {
                        if (o.equals(player)) continue;
                        int cnt = o.getResourceCount(target);
                        if (cnt > 0) {
                            o.removeResource(target, cnt);
                            player.addResource(target, cnt);
                            stolen += cnt;
                        }
                    }
                    log("  " + player.getColor() + " plays MONOPOLY on " + target
                            + ": steals " + stolen);
                    return;

                default:
                    break;
            }
        }
    }

    // ================================================================
    //                 SPECIAL CARDS (Longest Road / Largest Army)
    // ================================================================

    private void updateLongestRoad() {
        for (Player p : players) {
            int len = p.calculateLongestRoad();
            if (len >= 5 && len > longestRoadLength) {
                if (longestRoadHolder != null) longestRoadHolder.setLongestRoad(false);
                longestRoadHolder = p;
                longestRoadLength = len;
                p.setLongestRoad(true);
                log("  *** " + p.getColor() + " takes LONGEST ROAD (" + len + ") ***");
            }
        }
    }

    private void updateLargestArmy() {
        for (Player p : players) {
            int k = p.getKnightsPlayed();
            if (k >= 3 && k > largestArmySize) {
                if (largestArmyHolder != null) largestArmyHolder.setLargestArmy(false);
                largestArmyHolder = p;
                largestArmySize = k;
                p.setLargestArmy(true);
                log("  *** " + p.getColor() + " takes LARGEST ARMY (" + k + ") ***");
            }
        }
    }

    // ================================================================
    //                         UTILITY
    // ================================================================

    /** Pip count = probability weight for a number token. */
    private int pips(int number) {
        switch (number) {
            case 2: case 12: return 1;
            case 3: case 11: return 2;
            case 4: case 10: return 3;
            case 5: case 9:  return 4;
            case 6: case 8:  return 5;
            default:         return 0;
        }
    }

    private void log(String msg) {
        gameTrace.add(msg);
        System.out.println(msg);
    }

    private void logBoardLayout() {
        log("\n--- Board Layout ---");
        for (Tile t : board.getTiles()) log("  " + t);
    }

    private void logFinalState() {
        log("\n=== Final Standings ===");
        List<Player> sorted = new ArrayList<>(players);
        sorted.sort((a, b) -> b.getVictoryPoints() - a.getVictoryPoints());
        int rank = 1;
        for (Player p : sorted) {
            log("  #" + rank++ + " " + p.getColor()
                    + ": " + p.getVictoryPoints() + " VP"
                    + " (" + p.getSettlements().size() + "S, "
                    + p.getCities().size() + "C, "
                    + p.getRoads().size() + "R, "
                    + p.getKnightsPlayed() + "K)");
        }
        if (longestRoadHolder != null)
            log("  Longest Road: " + longestRoadHolder.getColor() + " (" + longestRoadLength + ")");
        if (largestArmyHolder != null)
            log("  Largest Army: " + largestArmyHolder.getColor() + " (" + largestArmySize + ")");
    }

    // ==================== Public Getters ====================

    public Board getBoard()              { return board; }
    public List<Player> getPlayers()     { return Collections.unmodifiableList(players); }
    public Player getCurrentPlayer()     { return currentPlayer; }
    public int getRoundCount()           { return roundCount; }
    public int getTurnCount()            { return turnCount; }
    public boolean isGameOver()          { return gameOver; }
    public Player getWinner()            { return winner; }
    public List<String> getGameTrace()   { return Collections.unmodifiableList(gameTrace); }
}
