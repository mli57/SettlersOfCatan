// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package SettlersOfCatan;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Represents a hexagonal terrain tile on the Catan board.
 * Uses cube coordinates (q, r, s) where q + r + s = 0.
 * Each tile has a terrain type, a number token (2-12), and
 * references to its 6 surrounding nodes and 6 edges.
 *
 * UML: abstract Tile with attributes q, r, s, resource, number, nodes[6], edges[6].
 */
public class Tile {

    private final int q;
    private final int r;
    private final int s;
    private final TerrainType resource;
    private int number;
    private boolean hasRobber;
    private final List<Node> nodes;
    private final List<Edge> edges;

    public Tile(int q, int r, int s, TerrainType resource) {
        if (q + r + s != 0) {
            throw new IllegalArgumentException(
                "Cube coordinates must sum to 0: q=" + q + " r=" + r + " s=" + s);
        }
        this.q = q;
        this.r = r;
        this.s = s;
        this.resource = resource;
        this.number = 0;
        this.hasRobber = (resource == TerrainType.DESERT);
        this.nodes = new ArrayList<>(6);
        this.edges = new ArrayList<>(6);
    }

    /**
     * Produces the resource associated with this tile's terrain type.
     * Returns null if the tile is desert or the robber is blocking production.
     * @return the ResourceType produced, or null
     */
    public ResourceType produceResource() {
        if (hasRobber || resource == TerrainType.DESERT) {
            return null;
        }
        return terrainToResource(resource);
    }

    /**
     * Maps a TerrainType to the corresponding ResourceType.
     */
    public static ResourceType terrainToResource(TerrainType terrain) {
        switch (terrain) {
            case WOOD:   return ResourceType.WOOD;
            case BRICK:  return ResourceType.BRICK;
            case SHEEP:  return ResourceType.SHEEP;
            case WHEAT:  return ResourceType.WHEAT;
            case ORE:    return ResourceType.ORE;
            case DESERT: return null;
            default:     return null;
        }
    }

    /**
     * Gets all tiles adjacent to this tile (share an edge in cube-coordinate space).
     * Two tiles are adjacent if their cube-coordinate Manhattan distance is exactly 2
     * and no single coordinate differs by more than 1.
     * @param allTiles the complete list of tiles on the board
     * @return list of adjacent tiles
     */
    public List<Tile> getAdjacentTiles(List<Tile> allTiles) {
        List<Tile> adjacent = new ArrayList<>();
        for (Tile other : allTiles) {
            if (other == this) continue;
            int dq = Math.abs(this.q - other.q);
            int dr = Math.abs(this.r - other.r);
            int ds = Math.abs(this.s - other.s);
            if ((dq + dr + ds) == 2 && dq <= 1 && dr <= 1 && ds <= 1) {
                adjacent.add(other);
            }
        }
        return adjacent;
    }

    // ========== Getters / Setters ==========

    public int getQ()             { return q; }
    public int getR()             { return r; }
    public int getS()             { return s; }
    public TerrainType getResource() { return resource; }
    public int getNumber()        { return number; }
    public void setNumber(int n)  { this.number = n; }
    public boolean hasRobber()    { return hasRobber; }
    public void setRobber(boolean b) { this.hasRobber = b; }

    public List<Node> getNodes()  { return nodes; }
    public void addNode(Node node) {
        if (!nodes.contains(node)) nodes.add(node);
    }

    public List<Edge> getEdges()  { return edges; }
    public void addEdge(Edge edge) {
        if (!edges.contains(edge)) edges.add(edge);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Tile)) return false;
        Tile t = (Tile) o;
        return q == t.q && r == t.r && s == t.s;
    }

    @Override
    public int hashCode() {
        return Objects.hash(q, r, s);
    }

    @Override
    public String toString() {
        String rob = hasRobber ? " [ROBBER]" : "";
        return String.format("Tile(%d,%d,%d) %s #%d%s", q, r, s, resource, number, rob);
    }
}
