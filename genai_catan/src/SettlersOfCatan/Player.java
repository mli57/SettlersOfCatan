// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package SettlersOfCatan;

import java.util.*;

/**
 * Represents a player in Settlers of Catan.
 * Manages resources, buildings, roads, development cards, and victory points.
 *
 * UML: Player with attributes color, resources (Map), Settlements, cities, roads, victoryPoints.
 *       Operations: addResource, removeResource, canBuildRoad, canBuildSettlement,
 *                   canBuildCity, getVictoryPoints.
 */
public class Player {

    // ========== Building Costs (per Catan rulebook) ==========
    public static final Map<ResourceType, Integer> ROAD_COST = Map.of(
            ResourceType.BRICK, 1, ResourceType.WOOD, 1);

    public static final Map<ResourceType, Integer> SETTLEMENT_COST = Map.of(
            ResourceType.BRICK, 1, ResourceType.WOOD, 1,
            ResourceType.SHEEP, 1, ResourceType.WHEAT, 1);

    public static final Map<ResourceType, Integer> CITY_COST = Map.of(
            ResourceType.ORE, 3, ResourceType.WHEAT, 2);

    public static final Map<ResourceType, Integer> DEV_CARD_COST = Map.of(
            ResourceType.ORE, 1, ResourceType.SHEEP, 1, ResourceType.WHEAT, 1);

    // ========== Supply limits per player ==========
    public static final int MAX_SETTLEMENTS = 5;
    public static final int MAX_CITIES      = 4;
    public static final int MAX_ROADS       = 15;

    // ========== Fields matching UML ==========
    private final PlayerColor color;
    private final Map<ResourceType, Integer> resources;
    private final List<Settlement> settlements;
    private final List<City> cities;
    private final List<Road> roads;
    private int victoryPoints; // cached, recalculated via getVictoryPoints()

    // Development card tracking
    private final List<DevelopmentCard> developmentCards;
    private int knightsPlayed;
    private boolean hasLongestRoad;
    private boolean hasLargestArmy;

    public Player(PlayerColor color) {
        this.color = color;
        this.resources = new EnumMap<>(ResourceType.class);
        for (ResourceType r : ResourceType.values()) {
            resources.put(r, 0);
        }
        this.settlements = new ArrayList<>();
        this.cities = new ArrayList<>();
        this.roads = new ArrayList<>();
        this.developmentCards = new ArrayList<>();
        this.knightsPlayed = 0;
        this.hasLongestRoad = false;
        this.hasLargestArmy = false;
    }

    // ==================== Resource Management ====================

    public void addResource(ResourceType res) {
        addResource(res, 1);
    }

    public void addResource(ResourceType res, int amount) {
        resources.put(res, resources.get(res) + amount);
    }

    /**
     * Removes the specified amount of a resource.
     * @return true if successful, false if insufficient resources
     */
    public boolean removeResource(ResourceType res, int amount) {
        if (resources.get(res) < amount) return false;
        resources.put(res, resources.get(res) - amount);
        return true;
    }

    public boolean removeResource(ResourceType res) {
        return removeResource(res, 1);
    }

    public int getResourceCount(ResourceType res) {
        return resources.get(res);
    }

    public int getTotalResourceCount() {
        return resources.values().stream().mapToInt(Integer::intValue).sum();
    }

    public Map<ResourceType, Integer> getResources() {
        return Collections.unmodifiableMap(resources);
    }

    /**
     * Checks if the player can afford the given cost map.
     */
    public boolean canAfford(Map<ResourceType, Integer> cost) {
        for (Map.Entry<ResourceType, Integer> e : cost.entrySet()) {
            if (resources.get(e.getKey()) < e.getValue()) return false;
        }
        return true;
    }

    /**
     * Pays (deducts) the given cost from resources.
     * @return true if payment succeeded
     */
    public boolean payCost(Map<ResourceType, Integer> cost) {
        if (!canAfford(cost)) return false;
        for (Map.Entry<ResourceType, Integer> e : cost.entrySet()) {
            resources.put(e.getKey(), resources.get(e.getKey()) - e.getValue());
        }
        return true;
    }

    /**
     * Discards half of resource cards (rounded down) when a 7 is rolled
     * and the player holds more than 7 cards.
     * Strategy: discards most-abundant resources first.
     * @return list of discarded resource types
     */
    public List<ResourceType> discardHalf() {
        int total = getTotalResourceCount();
        if (total <= 7) return Collections.emptyList();

        int toDiscard = total / 2;
        List<ResourceType> discarded = new ArrayList<>();

        // Sort resource types by count descending
        List<ResourceType> sorted = new ArrayList<>(Arrays.asList(ResourceType.values()));
        sorted.sort((a, b) -> resources.get(b) - resources.get(a));

        int remaining = toDiscard;
        for (ResourceType r : sorted) {
            while (remaining > 0 && resources.get(r) > 0) {
                removeResource(r);
                discarded.add(r);
                remaining--;
            }
        }
        return discarded;
    }

    // ==================== Building Checks ====================

    public boolean canBuildRoad() {
        return roads.size() < MAX_ROADS && canAfford(ROAD_COST);
    }

    public boolean canBuildSettlement() {
        return settlements.size() < MAX_SETTLEMENTS && canAfford(SETTLEMENT_COST);
    }

    public boolean canBuildCity() {
        return cities.size() < MAX_CITIES && !settlements.isEmpty() && canAfford(CITY_COST);
    }

    public boolean canBuyDevelopmentCard() {
        return canAfford(DEV_CARD_COST);
    }

    // ==================== Building Management ====================

    public void addSettlement(Settlement s)    { settlements.add(s); }
    public void removeSettlement(Settlement s) { settlements.remove(s); }
    public void addCity(City c)                { cities.add(c); }
    public void addRoad(Road r)                { roads.add(r); }
    public void addDevelopmentCard(DevelopmentCard c) { developmentCards.add(c); }

    // ==================== Victory Points ====================

    /**
     * Calculates total victory points including hidden VP development cards.
     * VP sources: settlements (1 each), cities (2 each), longest road (2),
     *             largest army (2), VP dev cards (1 each).
     */
    public int getVictoryPoints() {
        int vp = settlements.size();        // 1 VP each
        vp += cities.size() * 2;            // 2 VP each
        if (hasLongestRoad) vp += 2;
        if (hasLargestArmy) vp += 2;
        for (DevelopmentCard c : developmentCards) {
            if (c.getType() == DevelopmentCardType.VICTORY_POINT) {
                vp += 1;
            }
        }
        this.victoryPoints = vp;
        return vp;
    }

    /**
     * Victory points visible to other players (excludes hidden VP dev cards).
     */
    public int getVisibleVictoryPoints() {
        int vp = settlements.size() + cities.size() * 2;
        if (hasLongestRoad) vp += 2;
        if (hasLargestArmy) vp += 2;
        return vp;
    }

    // ==================== Longest Road ====================

    /**
     * Calculates this player's longest continuous road.
     */
    public int calculateLongestRoad() {
        int max = 0;
        for (Road road : roads) {
            max = Math.max(max, road.getLongestRoadCount());
        }
        return max;
    }

    // ==================== Development Cards ====================

    public int getKnightsPlayed()        { return knightsPlayed; }
    public void incrementKnightsPlayed() { knightsPlayed++; }

    public List<DevelopmentCard> getDevelopmentCards() {
        return Collections.unmodifiableList(developmentCards);
    }

    // ==================== Robber: random steal ====================

    /**
     * Returns a random resource from this player's hand (for robber stealing).
     * @return a random ResourceType, or null if hand is empty
     */
    public ResourceType getRandomResource(Random random) {
        if (getTotalResourceCount() == 0) return null;
        List<ResourceType> all = new ArrayList<>();
        for (Map.Entry<ResourceType, Integer> e : resources.entrySet()) {
            for (int i = 0; i < e.getValue(); i++) {
                all.add(e.getKey());
            }
        }
        return all.get(random.nextInt(all.size()));
    }

    // ==================== Getters / Setters ====================

    public PlayerColor getColor()            { return color; }
    public List<Settlement> getSettlements() { return settlements; }
    public List<City> getCities()            { return cities; }
    public List<Road> getRoads()             { return roads; }

    public boolean hasLongestRoad()                  { return hasLongestRoad; }
    public void setLongestRoad(boolean v)            { this.hasLongestRoad = v; }
    public boolean hasLargestArmy()                  { return hasLargestArmy; }
    public void setLargestArmy(boolean v)            { this.hasLargestArmy = v; }

    public String getResourceSummary() {
        StringBuilder sb = new StringBuilder();
        for (ResourceType r : ResourceType.values()) {
            sb.append(r.name()).append("=").append(resources.get(r)).append(" ");
        }
        return sb.toString().trim();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Player)) return false;
        return color == ((Player) o).color;
    }

    @Override
    public int hashCode() { return color.hashCode(); }

    @Override
    public String toString() {
        return String.format("Player(%s) VP=%d [%s]", color, getVictoryPoints(), getResourceSummary());
    }
}
