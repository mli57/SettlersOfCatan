// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package SettlersOfCatan;

import java.util.ArrayList;
import java.util.List;

/**
 * Represents an intersection (vertex) on the Catan board where up to 3 hexes meet.
 * Settlements and cities are placed on nodes.
 *
 * UML: Node with attributes id, building, occupyingPlayer.
 *       Operations: canPlaceBuilding(), getAdjacentNodes(), getAdjacentTiles().
 */
public class Node {

    private final int id;
    private Building building;
    private Player occupyingPlayer;
    private final List<Edge> edges;
    private final List<Tile> adjacentTiles;
    private final List<Node> adjacentNodes;

    public Node(int id) {
        this.id = id;
        this.building = null;
        this.occupyingPlayer = null;
        this.edges = new ArrayList<>(3);
        this.adjacentTiles = new ArrayList<>(3);
        this.adjacentNodes = new ArrayList<>(3);
    }

    /**
     * Checks whether a building can be placed on this node.
     * Enforces the Distance Rule: all 3 adjacent intersections must be vacant.
     * @return true if unoccupied and no adjacent node has a building
     */
    public boolean canPlaceBuilding() {
        if (building != null) {
            return false;
        }
        for (Node neighbour : adjacentNodes) {
            if (neighbour.getBuilding() != null) {
                return false;
            }
        }
        return true;
    }

    /**
     * Extended check: can this specific player build a settlement here?
     * During setup the road-connectivity check is skipped.
     * During normal play the player must have a road to this node.
     */
    public boolean canPlaceSettlement(Player player, boolean isSetupPhase) {
        if (!canPlaceBuilding()) {
            return false;
        }
        if (isSetupPhase) {
            return true;
        }
        // Normal play: player must have at least one road leading here
        for (Edge edge : edges) {
            if (edge.getRoad() != null && edge.getRoad().getOwner().equals(player)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Places a building on this node.
     */
    public void placeBuilding(Building building, Player player) {
        this.building = building;
        this.occupyingPlayer = player;
    }

    /**
     * Upgrades the existing settlement to a city.
     */
    public void upgradeToCity(City city) {
        if (!(this.building instanceof Settlement)) {
            throw new IllegalStateException("Can only upgrade a Settlement to a City");
        }
        this.building = city;
    }

    // ========== Adjacency management ==========

    public List<Node> getAdjacentNodes() { return adjacentNodes; }
    public void addAdjacentNode(Node n) {
        if (!adjacentNodes.contains(n)) adjacentNodes.add(n);
    }

    public List<Tile> getAdjacentTiles() { return adjacentTiles; }
    public void addAdjacentTile(Tile t) {
        if (!adjacentTiles.contains(t)) adjacentTiles.add(t);
    }

    public List<Edge> getEdges() { return edges; }
    public void addEdge(Edge e) {
        if (!edges.contains(e)) edges.add(e);
    }

    // ========== Getters ==========

    public int getId()                   { return id; }
    public Building getBuilding()        { return building; }
    public Player getOccupyingPlayer()   { return occupyingPlayer; }
    public boolean isOccupied()          { return building != null; }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Node)) return false;
        return id == ((Node) o).id;
    }

    @Override
    public int hashCode() { return id; }

    @Override
    public String toString() {
        String bldg = building == null ? "empty" : building.getClass().getSimpleName();
        return String.format("Node(%d) [%s]", id, bldg);
    }
}
